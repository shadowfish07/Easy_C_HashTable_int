# 二维字符数组和指针的相应问题研究
>在尝试用C语言实现广度优先算法时，需要用到支持以二维字符数组为值的哈希表，于是我对自己前面实现的int型键值对的哈希表进行再加工，发现在定义二维字符数组和指针时遇到较大问题，特此记录
>>张谦煜 2019/10/24
## 将已知的二维字符数组传入以储存
### 尝试
一开始，我将待传入的二维字符数组定义为  
`char a[][30]={"ABCD","EFDG","12122"};`  
此代码创建了char类型3行30列 *（3个字符串，每个字符串30个字节）* 的二维数组。  
接着，我尝试用一个二级指针指向它  
`char **ap =a;`  
并读取它的第一行字符串  
`printf("%s",*ap);`  
编译，运行到`printf("%s",*ap);` 时报错`Segmentation fault`，即`段错误`，访问了**不可访问**的内存。
### 原因
`*ap`的值类型为`char*` *（指向char的指针）* ，而它实际存储的是`char`型二维数组`a`的第一行数据的值 *(本质是int型数据)* ，而不是指向`a`的第一行数据的首地址。这就导致程序将`int`型数据当作地址访问，自然访问了**不可访问**的内存。
#### 补充
`char* p;`字符指针`p`相当于一维字符数组**名**，`printf("%s",p)`中`p`指向字符数组首地址，配合`"%s"`格式化输出相当于从首地址开始逐个输出各个字符，到`"/0"`结束。
### 解决
既然出现问题的原因是`*ap`指向了`int`型数据，那么我们需要让它指向真正的字符数组首地址。我们将待传入的二维字符数组定义改为
`char *a[30]={"ABCD","EFDG","12122"};`  
这种定义方式创建了长度为`30`的**字符型指针数组**(`char* []`)，指针数组里的每个指针指向各个字符数组（字符串）的首地址。  
`char **ap =a;`  
用`**ap`指向它后，`*ap`（即`ap[0]`)存储的是**字符型指针变量**(`char*`)的首地址。  
`printf("%s",*ap);`  
此时引用`*ap`进行输出，传递进的是指向`a`第一行首地址的字符型指针(`char*`)(等效于`*a`或`a[0]`)，从而输出了`a`第一行的所有字符。  

我制作了便于直观理解的图表：
![二维字符数组和指针的相应问题研究.png](https://i.loli.net/2019/10/24/M1TyDd2uZWY7VoX.png)

#### 思考
定义变量时，调整`*`的位置，可以更好地理解  
`char* a[30];`  
`char* *ap;`  
若将表示字符型指针(`char*`)的`*`贴近`char`，可以很清楚地看出，`a[30]`是一个`char*`类型的数组，即字符型指针数组；`*ap`是一个`char*`类型的指针，即指向字符型指针的指针。

---

**注意**  
`char *a[30]={"ABCD","EFDG","12122"};`  
`char (*a)[30]={"ABCDEFDG12122"};`  
上述两种定义方式有很大的区别。第一种创建了长度为`30`的`char`型指针数组，指针数组中的每个指针指向各个字符数组（字符串）的首地址；第二种创建了指向一个长度为`30`的 `char`型数组的指针。  
此处两种方式都为`a`赋了初值。第一种方式将指针数组里的前三个指针指向三个字符数组（字符串）；第二种方式初始化了被`a`指向的字符数组的前面部分字节。  
第二种方式若像第一种方式一样赋初值  
`char (*a)[30]={"ABCD","EFDG","12122"};`  
由于这只是一个一维字符数组，只会存储`"ABCD"`，后面的字符串不会被存储。

---



