# 二维字符数组和指针的相应问题研究
>在尝试用C语言实现广度优先算法时，需要用到支持以二维字符数组为值的哈希表，于是我对自己前面实现的int型键值对的哈希表进行再加工，发现在定义二维字符数组和指针时遇到较大问题，特此记录
## 将已知的二维字符数组传入以储存
### 尝试
一开始，我将待传入的二维字符数组定义为  
`char a[][30]={"ABCD","EFDG","12122"};`  
此代码创建了char类型3行30列 *（3个字符串，每个字符串30个字节）* 的二维数组。  
接着，我尝试用一个二级指针指向它  
`char **ap =a;`  
并读取它的第一行字符串  
`printf("%s",*ap);`  
编译，运行到`printf("%s",*ap);` 时报错`Segmentation fault`，即`段错误`，访问了**不可访问**的内存。
### 原因
`*ap`的值类型为`char*` *（指向char的指针）* ，而它实际存储的是`char`型二维数组`a`的第一行数据的值 *(本质是int型数据)* ，而不是指向`a`的第一行数据的首地址。这就导致程序将`int`型数据当作地址访问，自然访问了**不可访问**的内存。
#### 补充
`char* p;`字符指针`p`相当于一维字符数组**名**，`printf("%s",p)`中`p`指向字符数组首地址，配合`"%s"`格式化输出相当于从首地址开始逐个输出各个字符，到"/0"结束。
### 解决
既然出现问题的原因是`*ap`指向了`int`型数据，那么我们需要让它指向真正的字符数组首地址。我们将待传入的二维字符数组定义改为
`char *a[30]={"ABCD","EFDG","12122"};`  
这种定义方式创建了长度为`30`的`char`型指针数组，指针数组里的每个指针指向各个字符数组（字符串）的首地址。

---

**注意**  
`char *a[30]={"ABCD","EFDG","12122"};`  
`char (*a)[30]={"ABCDEFDG12122"};`  
上述两种定义方式有很大的区别。第一种创建了长度为`30`的`char`型指针数组，指针数组中的每个指针指向各个字符数组（字符串）的首地址；第二种创建了指向一个长度为`30`的 `char`型数组的指针。  
此处两种方式都为`a`赋了初值。第一种方式将指针数组里的前三个指针指向三个字符数组（字符串）；第二种方式初始化了被`a`指向的字符数组的前面部分字节。  
第二种方式若像第一种方式一样赋初值  
`char (*a)[30]={"ABCD","EFDG","12122"};`  
由于这只是一个一维字符数组，只会存储`"ABCD"`，后面的字符串不会被存储。

---



